<!doctype html><style>html{height:100vh}body{min-height:100vh;display:grid;grid-template-rows:1fr auto}.footer{grid-row-start:2;grid-row-end:3}</style><html lang=en-gb><head><meta charset=utf-8><title>Portfolio</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description property="og:description" content="AOSV Final Project"><meta name=image property="og:image" content="/"><meta name=author content="Sultan Umarbaev"><meta name=generator content="Hugo 0.110.0"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/uikit@3.2.6/dist/css/uikit.min.css><link rel=stylesheet href=/css/style.min.css integrity media=screen><link rel=stylesheet href=/css/syntax.min.css integrity media=screen><script src=https://cdn.jsdelivr.net/npm/mailgo@0.9.14/dist/mailgo.min.js defer></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="portfolio dark-mode"><div class=wrapper><div uk-sticky="sel-target: .uk-navbar-container; cls-active: uk-navbar-sticky; bottom: #transparent-sticky-navbar"><nav class="uk-navbar-container uk-margin" uk-navbar="mode: click;" style=padding-right:3rem><div class=uk-navbar-right><ul class="uk-navbar-nav uk-visible@s"><li><a style=font-size:18px;text-transform:none href=/>Home</a></li><li><a style=font-size:18px;text-transform:none href=/about>About</a></li><li><a style=font-size:18px;text-transform:none href=/blog>Blog</a></li><li class=uk-active><a style=font-size:18px;text-transform:none href=/portfolio>Portfolio</a></li></ul><a class="uk-navbar-toggle uk-hidden@s" uk-toggle="target: #sidenav" uk-navbar-toggle-icon href=#></a></div></nav></div><div id=sidenav uk-offcanvas="overlay: true"><div class="uk-offcanvas-bar uk-flex uk-flex-column"><ul class="uk-nav uk-nav-primary uk-nav-center uk-margin-auto-vertical"><li><a style=font-size:18px href=https://umarbaev-s.github.io>Home</a></li><li><a style=font-size:18px href=/about>About</a></li><li><a style=font-size:18px href=/blog>Blog</a></li><li class=uk-active><a style=font-size:18px href=/portfolio>Portfolio</a></li></ul></div></div><style>p{margin:0}.people-wrap{display:inline-flex;margin-top:10px}.people-image{display:block;border-radius:50%}.people{margin-left:20px;margin-right:20px}.name{margin:auto}h1,h2,h3,h4,h5,h6{color:#000;font-family:Roboto,sans-serif;line-height:1.2;margin-top:2rem}.content img{box-shadow:0 4px 8px rgba(0,0,0,.2),0 6px 20px rgba(0,0,0,.19);display:block;margin-left:auto;margin-right:auto;margin-bottom:30px}p{margin-bottom:1em}body p:last-child{margin-bottom:0}img.skills{height:80px}@media only screen and (min-width:960px){.content img{max-width:60vw;max-height:60vh}.content img{max-width:60vw;max-height:60vh}}.content{width:90vw;max-width:1200px}table{font-family:arial,sans-serif;border-collapse:collapse;width:100%}td,th{border:1px solid #ddd;text-align:left;padding:8px}</style><section><div class="uk-container uk-margin-large-bottom uk-margin-medium-top"><h1 class="uk-text-center uk-heading-medium">User Mode thread Scheduling</h1><p class="uk-text-center uk-text-lead">AOSV Final Project</p><p class=uk-text-center>Published on Jul 03, 2023</p><p class=uk-text-center>Reading time: 3 minutes.</p><div class="uk-child-width-1-4@m uk-child-width-1-2@s uk-text-center uk-flex-center uk-grid-large uk-margin-small-top" uk-grid><div><a class="uk-button uk-button-default" href=https://github.com/umarbaev-S/AOSV-project><span uk-icon="icon: github"></span>
Github</a></div></div><hr class=full-width><h2 class="uk-text-center uk-heading-small">Built with</h2><section><div class=uk-container><div class="uk-child-width-1-6@l uk-child-width-1-3@m uk-child-width-1-3@s uk-child-width-1-2 uk-text-center uk-flex-center" uk-grid><div class=imagemargin><a href=https://en.cppreference.com/w/c/language><img class="contain skills" src=https://raw.githubusercontent.com/umarbaev-S/umarbaev-s.github.io/master/static/images/skills/c.svg alt=C loading=lazy style=cursor:pointer></a></div></div></div></section><hr class=full-width><div class=content><h1 id=aosv-final-project-report>AOSV Final Project Report</h1><p><em>A.Y. 2020/2021</em></p><h1 id=introduction>Introduction</h1><p>The goal of the project was to implement <strong>User Mode thread Scheduling</strong> mechanism for the Linux distribution, inspired by the <strong>User-mode scheduling (UMS)</strong> implementation available in the Windows kernel [1]. UMS is a mechanism that allows applications/programs in the user mode to schedule their own threads without involving the kernel/system scheduler. The main goal and advantage is that thread switching in user mode is &ldquo;<em>more efficient than thread pools for managing large numbers of short-duration work items that require few system calls.</em>&rdquo; [2].</p><h1 id=design-and-implementation>Design and Implementation</h1><p>The main components of the UMS mechanism in this implementation are:</p><ul><li><em>ums thread</em>, the scheduler that determines the next worker thread to be scheduled and executed</li><li><em>worker thread</em>, the short-duration work tasks of the application</li><li><em>completion list</em>, the list of worker threads to be associated with scheduler</li></ul><p>The execution flow is shown below:
<img src=../media/ums/execution_flow.jpg alt="exec flow"></p><p>As shown in the flow, in order to begin utilization of UMS mechanism the application in user space needs to initialize it by <code>init_ums()</code>. It makes IOCTL call to invoke <code>init_ums_process()</code> which creates necessary structures associated with the application in kernel space.
After that, UMS mechanism is enabled for this application and user can create completion lists and worker threads. This is done with the help of <code>create_completion_list()</code> and <code>create_worker_thread()</code>. Worker threads are built with <em>task routine</em> and required parameters, and completion lists are filled with worker threads by <code>add_worker_thread()</code> manually.
The next important element is a <em>scheduling routine</em> which is a scheduling function. Once the completion lists are created and filled with worker threads, a <em>scheduling routine</em> needs to be created and together with id of the completion list passed to <code>enter_ums_scheduling_mode()</code> to invoke <code>create_ums_thread()</code> in kernel space which creates corresponding scheduler context. Then <code>enter_ums_scheduling_mode()</code> invokes <code>pthread_create()</code> [5] to start new thread in the calling process environment. The new thread starts the execution of the <code>convert_to_ums_thread()</code> which converts itself into scheduler. This is done <code>convert_to_ums_thread()</code> in kernel space which performs context switching.
From that point pthread is converted to scheduler thread and the <em>scheduling routine</em> is being executed. Before starting the scheduling of worker threads, scheduler needs to query a list of currently available/ready worker threads to be run by <code>dequeue_completion_list_items()</code> which calls corresponding function in kernel space.
Worker thread scheduling and execution is performed by iterating over the list of ready worker threads and invoking <code>execute_worker_thread()</code>. The corresponding function in kernel space <code>switch_to_worker_thread()</code> performs context switching operation from scheduler to worker thread context. Once worker thread finishes its routine, <code>worker_thread_yield()</code> is called with specified yield reason which determines whether worker thread is pausing or finishing. Similarly to worker thread execution, the context switching from worker thread back to scheduler is carried out on worker thread yield in kernel space by <code>switch_back_to_ums_thread()</code>.
Finished <em>scheduling routine</em> calls <code>exit_ums_scheduling_mode()</code> to invoke <code>convert_from_ums_thread()</code> on the kernel space to convert scheduler back to pthread. And after that each converted from scheduler thread calls <code>exit_ums()</code> to synchronize the execution of schedulers.</p><h1 id=results>Results</h1><p>The implementation was built on the following environment:</p><ul><li>Operating System: Ubuntu 20.04.2 LTS</li><li>Kernel: Linux 5.11.0-40-generic</li><li>Architecture: x86-64</li></ul><p>The log information examples of the library and module are shown the following pictures:
<img src=../media/ums/lib_log_info.png alt="library log"></p><p><img src=../media/ums/module_log_info.png alt="module log1"></p><p><img src=../media/ums/module_log_info_2.png alt="module log2"></p><p>The measured benchmark sample of the project is the average time needed for a scheduler thread to switch a worker thread which is in range between 150-250 ms.</p><p>The process of executing the worker threads is straight-forward and not optimized completely. Scheduler routine in user space queries(dequeue) a list of available and ready to run worker threads and stores it locally. Thus, when 2 scheduler share a completion list, it is not updated globally. Scheduler updates a local list during the execution attempt of a worker thread, specifically when it sees that the status of the worker thread is finished. Thus, there might be cases when one scheduler finishes the whole list and another scheduler is just trailing behind and updating local list.
Another case to be noted and reported is when one scheduler finishes the list even before the second scheduler has started.</p><h1 id=references>References</h1><ol><li><a href=https://gpm.name/teaching/2021-aosv/news/2021/04/09/final-project-track/>https://gpm.name/teaching/2021-aosv/news/2021/04/09/final-project-track/</a></li><li><a href=https://docs.microsoft.com/en-us/windows/win32/procthread/user-mode-scheduling>https://docs.microsoft.com/en-us/windows/win32/procthread/user-mode-scheduling</a></li><li><a href="https://www.youtube.com/watch?v=PYlP8MXRCZc">https://www.youtube.com/watch?v=PYlP8MXRCZc</a></li><li><a href=https://patents.google.com/patent/US20100083275A1/en>https://patents.google.com/patent/US20100083275A1/en</a></li><li><a href=https://man7.org/linux/man-pages/man7/pthreads.7.html>https://man7.org/linux/man-pages/man7/pthreads.7.html</a></li><li><a href=https://www.mcs.anl.gov/~kazutomo/list/list.h>https://www.mcs.anl.gov/~kazutomo/list/list.h</a></li></ol></div></div></div></section></div><footer class="footer dark-mode"><div class=uk-container><div class="uk-grid-small uk-child-width-1-4@m uk-text-center uk-flex-center uk-margin-medium-bottom" uk-grid><div class=uk-margin-small-bottom><h5 class=uk-margin-small-bottom>Email</h5><a href=mailto:0x5bjorn@gmail.com>0x5bjorn@gmail.com</a></div></div><div class="footer-copyright uk-text-center" style=padding-bottom:1rem><img loading=lazy src=https://mirrors.creativecommons.org/presskit/icons/cc.svg style=height:1.2em;width:1.2em alt="Creative Commons">
<img loading=lazy src=https://mirrors.creativecommons.org/presskit/icons/by.svg style=height:1.2em;width:1.2em alt=CC-BY>
2023
Sultan Umarbaev</div></div></footer><script src=https://cdn.jsdelivr.net/npm/uikit@3.2.6/dist/js/uikit.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/uikit@3.2.6/dist/js/uikit-icons.min.js></script></body></html>